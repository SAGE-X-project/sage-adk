# Storage Layer Design (Phase 1)

**Version**: 1.0
**Date**: 2025-10-07
**Status**: Design
**Author**: AI Agent Development Team

## 1. Overview

This document defines the storage abstraction layer for the SAGE Agent Development Kit. The storage layer provides persistent and temporary storage for agent data including message history, agent metadata, and context information.

## 2. Goals

### Primary Goals
1. **Storage Abstraction**: Unified interface for multiple storage backends
2. **Type Safety**: Strong typing for storage operations
3. **Thread Safety**: Concurrent access support
4. **Flexibility**: Support different storage strategies (memory, persistent)

### Phase 1 Scope
- Storage interface definition
- Memory storage implementation (for testing/development)
- Message history storage
- Basic CRUD operations

### Future Phases (Not Implemented)
- Redis backend for distributed agents
- PostgreSQL backend for production deployments
- Advanced querying (filtering, pagination)
- Data versioning and migration

## 3. Design Principles (from AI Agent Research)

### Progressive Disclosure
```go
// Simple: Store and retrieve messages
storage.Store(ctx, "history:agent1", msg)
msg, _ := storage.Get(ctx, "history:agent1", msgID)

// Advanced: Batch operations, filtering
msgs, _ := storage.List(ctx, "history:agent1", filters)
```

### Zero Overhead
- Direct map access for memory storage
- Minimal abstraction layers
- No unnecessary serialization in memory mode

### Developer Experience
- Clear error messages
- Simple key-based access
- Familiar CRUD interface

## 4. Architecture

### 4.1 Storage Interface

```go
// Storage defines the interface for data storage.
type Storage interface {
    // Store stores an item with the given key.
    Store(ctx context.Context, namespace, key string, value interface{}) error

    // Get retrieves an item by key.
    Get(ctx context.Context, namespace, key string) (interface{}, error)

    // List retrieves all items in a namespace.
    List(ctx context.Context, namespace string) ([]interface{}, error)

    // Delete removes an item by key.
    Delete(ctx context.Context, namespace, key string) error

    // Clear removes all items in a namespace.
    Clear(ctx context.Context, namespace string) error

    // Exists checks if a key exists.
    Exists(ctx context.Context, namespace, key string) (bool, error)
}
```

### 4.2 Namespace Strategy

- `history:<agent-id>`: Message history for an agent
- `metadata:<agent-id>`: Agent metadata and configuration
- `context:<context-id>`: Conversation context data
- `state:<agent-id>`: Agent state information

### 4.3 Memory Storage

Thread-safe in-memory storage using Go maps:

```go
type MemoryStorage struct {
    mu   sync.RWMutex
    data map[string]map[string]interface{}  // namespace -> key -> value
}
```

## 5. Implementation Plan

### Phase 1: Core Abstraction (This Design)
1. Define Storage interface (`storage/types.go`)
2. Implement MemoryStorage (`storage/memory.go`)
3. Write comprehensive tests (TDD, 90%+ coverage)
4. Package documentation (`storage/doc.go`)

### Phase 2: Persistent Backends (Future)
1. Redis storage implementation
2. PostgreSQL storage implementation
3. Connection pooling and retries

### Phase 3: Advanced Features (Future)
1. Filtering and pagination
2. TTL support for temporary data
3. Data migration utilities
4. Backup/restore operations

## 6. Usage Examples

### Example 1: Store Message History

```go
import (
    "github.com/sage-x-project/sage-adk/storage"
    "github.com/sage-x-project/sage-adk/pkg/types"
)

// Create storage
store := storage.NewMemoryStorage()

// Store messages
msg := &types.Message{MessageID: "msg-1", Content: "Hello"}
err := store.Store(ctx, "history:agent1", msg.MessageID, msg)

// Retrieve message
retrieved, err := store.Get(ctx, "history:agent1", "msg-1")
msg := retrieved.(*types.Message)

// List all messages for agent
messages, err := store.List(ctx, "history:agent1")
```

### Example 2: Agent Metadata Storage

```go
// Store agent metadata
metadata := map[string]string{
    "version": "1.0.0",
    "created": "2025-10-07",
}
store.Store(ctx, "metadata:agent1", "info", metadata)

// Retrieve metadata
info, _ := store.Get(ctx, "metadata:agent1", "info")
```

### Example 3: Context Management

```go
// Store conversation context
context := &ConversationContext{
    ID:      "ctx-123",
    AgentID: "agent1",
    History: []string{"msg-1", "msg-2", "msg-3"},
}
store.Store(ctx, "context:ctx-123", "data", context)

// Clear old contexts
store.Clear(ctx, "context:old-ctx-456")
```

## 7. Testing Strategy

### Unit Tests
- Test all CRUD operations
- Test namespace isolation
- Test concurrent access (race conditions)
- Test error cases (not found, nil values)

### Coverage Target
- Minimum 90% code coverage
- 100% of error paths tested

### Test Data
```go
func TestMemoryStorage_Store(t *testing.T) {
    store := storage.NewMemoryStorage()

    msg := &types.Message{MessageID: "test-1"}
    err := store.Store(ctx, "test", "key1", msg)
    if err != nil {
        t.Fatal(err)
    }

    // Verify storage
    retrieved, err := store.Get(ctx, "test", "key1")
    // ... assertions
}
```

## 8. Error Handling

Using existing error types from `pkg/errors`:

- `ErrNotFound`: Key not found in storage
- `ErrInvalidInput`: Invalid namespace or key (empty strings)
- `ErrStorageUnavailable`: Backend unavailable (future: Redis/PostgreSQL)

## 9. Performance Considerations

### Memory Storage
- O(1) access time for Get/Store/Delete
- O(n) for List operations
- No serialization overhead
- Limited by available RAM

### Future Backends
- Redis: Network latency consideration
- PostgreSQL: Connection pooling required
- Caching strategy for frequently accessed data

## 10. Security Considerations

### Phase 1
- In-memory storage: No persistence, data lost on restart (acceptable for testing)
- No encryption (data in process memory only)

### Future Phases
- Encrypt sensitive data at rest (Redis/PostgreSQL)
- Access control per namespace
- Audit logging for storage operations

## 11. Design Decisions

### Decision 1: Interface-First Approach
**Rationale**: Allows swapping backends without code changes
**Trade-off**: Additional abstraction layer, but minimal performance impact

### Decision 2: Namespace-Based Organization
**Rationale**: Logical separation of different data types, prevents key collisions
**Trade-off**: Slightly more complex key management, but better organization

### Decision 3: Generic interface{} Values
**Rationale**: Maximum flexibility for different data types
**Trade-off**: Type assertions required, but matches Go map behavior

### Decision 4: Memory-Only Phase 1
**Rationale**: Matches pattern from LLM (Mock), SAGE (basic), enables immediate testing
**Trade-off**: Not production-ready, but sufficient for ADK development

## 12. Integration with Agent

```go
agent, _ := agent.NewAgent("storage-agent").
    OnMessage(func(ctx context.Context, msg MessageContext) error {
        // Store incoming message
        storage.Store(ctx, "history:agent1", msg.ID(), msg.Message())

        // Retrieve conversation history
        history, _ := storage.List(ctx, "history:agent1")

        // Process with full context
        return processWithHistory(msg, history)
    }).
    Build()
```

## 13. References

- AI Agent Development Research (completed earlier)
- Storage patterns from LangChain, AutoGPT, CrewAI
- Go sync.Map patterns for concurrent access
- Redis/PostgreSQL best practices (for future phases)

## 14. Success Criteria

Phase 1 is successful when:
1.  Storage interface fully defined
2.  MemoryStorage implementation complete
3.  90%+ test coverage achieved
4.  All tests passing
5.  Package documentation complete
6.  Integration example provided

---

**Next Steps**: Implement storage interface and memory backend following TDD approach.
