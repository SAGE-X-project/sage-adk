# Protocol Layer Design

**Version**: 1.0
**Created**: 2025-10-07 02:46:48
**Status**: Design Phase
**Target**: core/protocol

---

## Overview

This document defines the protocol layer for SAGE ADK, enabling seamless support for both A2A and SAGE protocols with automatic detection and transparent switching.

### Design Goals

1. **Automatic Detection**: Auto-detect protocol from message metadata
2. **Transparent Switching**: Users don't need to know protocol details
3. **Extensibility**: Easy to add new protocols in the future
4. **Type Safety**: Compile-time guarantees for protocol operations
5. **Developer Joy**: Simple API for common cases, powerful for advanced use

### Key Insights from AI Agent Research

Based on our comprehensive analysis of AI agent development:

1. **Protocol abstraction should be invisible to users** - Developers shouldn't need to understand A2A vs SAGE details
2. **Auto-detection is preferred over manual configuration** - Follow LangGraph's pattern of smart defaults
3. **Adapters wrap existing implementations** - Don't reinvent sage-a2a-go or sage libraries
4. **Unified message interface** - Similar to how Claude API abstracts tool use across providers

---

## Design Principles

### 1. Protocol Modes

```go
type ProtocolMode int

const (
    ProtocolAuto ProtocolMode = iota  // Auto-detect (default)
    ProtocolA2A                         // A2A only
    ProtocolSAGE                        // SAGE only
)
```

**Usage Philosophy:**
- **Default**: `ProtocolAuto` - Let the system decide
- **Explicit**: Users can force a specific protocol when needed
- **Progressive**: Start with auto, upgrade to explicit only if necessary

### 2. Protocol Detection Strategy

```go
// Detection based on message metadata
func DetectProtocol(msg *types.Message) ProtocolMode {
    if msg.Security != nil && msg.Security.Mode == types.ProtocolModeSAGE {
        return ProtocolSAGE
    }
    return ProtocolA2A
}
```

**Detection Rules:**
1. Check `message.security.mode` field
2. If `mode == "sage"`, use SAGE protocol
3. Otherwise, default to A2A protocol

### 3. Adapter Pattern

Each protocol is wrapped in an adapter that implements a common interface:

```go
type ProtocolAdapter interface {
    // Name returns the protocol name
    Name() string

    // SendMessage sends a message using this protocol
    SendMessage(ctx context.Context, msg *types.Message) error

    // ReceiveMessage receives a message using this protocol
    ReceiveMessage(ctx context.Context) (*types.Message, error)

    // Verify verifies message authenticity (SAGE only, no-op for A2A)
    Verify(ctx context.Context, msg *types.Message) error
}
```

**Adapter Responsibilities:**
- **A2A Adapter**: Wraps `sage-a2a-go` library
- **SAGE Adapter**: Wraps `sage` library, handles handshake and signatures
- **Future Adapters**: Easy to add (e.g., OpenAI Agents, Anthropic MCP)

---

## Core Interfaces

### ProtocolSelector

```go
// ProtocolSelector manages protocol detection and selection.
type ProtocolSelector interface {
    // Select chooses the appropriate protocol for a message
    Select(msg *types.Message) ProtocolAdapter

    // Register registers a new protocol adapter
    Register(mode ProtocolMode, adapter ProtocolAdapter)

    // SetMode sets the protocol mode (auto, a2a, sage)
    SetMode(mode ProtocolMode)

    // GetMode returns the current protocol mode
    GetMode() ProtocolMode
}
```

### ProtocolAdapter

```go
// ProtocolAdapter provides a unified interface for different protocols.
type ProtocolAdapter interface {
    // Name returns the protocol name
    Name() string

    // SendMessage sends a message using this protocol
    SendMessage(ctx context.Context, msg *types.Message) error

    // ReceiveMessage receives a message (for server-side)
    ReceiveMessage(ctx context.Context) (*types.Message, error)

    // Verify verifies message authenticity
    Verify(ctx context.Context, msg *types.Message) error

    // SupportsStreaming returns true if protocol supports streaming
    SupportsStreaming() bool

    // Stream sends a streaming response
    Stream(ctx context.Context, fn StreamFunc) error
}

// StreamFunc is called for each chunk in a streaming response
type StreamFunc func(chunk *types.Message) error
```

---

## Implementation Design

### Package Structure

```
core/protocol/
├── doc.go              # Package documentation
├── selector.go         # ProtocolSelector implementation
├── selector_test.go    # Selector tests
├── adapter.go          # ProtocolAdapter interface
├── adapter_test.go     # Adapter tests
├── detector.go         # Protocol detection logic
├── detector_test.go    # Detection tests
└── mock_adapter.go     # Mock adapter for testing
```

### ProtocolSelector Implementation

```go
// selector implements ProtocolSelector.
type selector struct {
    mode     ProtocolMode
    adapters map[ProtocolMode]ProtocolAdapter
    mu       sync.RWMutex
}

// NewSelector creates a new protocol selector.
func NewSelector(mode ProtocolMode) ProtocolSelector {
    return &selector{
        mode:     mode,
        adapters: make(map[ProtocolMode]ProtocolAdapter),
    }
}

// Select chooses the appropriate protocol for a message.
func (s *selector) Select(msg *types.Message) ProtocolAdapter {
    s.mu.RLock()
    defer s.mu.RUnlock()

    mode := s.mode

    // Auto-detect if mode is Auto
    if mode == ProtocolAuto {
        mode = DetectProtocol(msg)
    }

    // Get adapter for the selected mode
    adapter, ok := s.adapters[mode]
    if !ok {
        // Fallback to A2A if adapter not found
        adapter = s.adapters[ProtocolA2A]
    }

    return adapter
}

// Register registers a protocol adapter.
func (s *selector) Register(mode ProtocolMode, adapter ProtocolAdapter) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.adapters[mode] = adapter
}

// SetMode sets the protocol mode.
func (s *selector) SetMode(mode ProtocolMode) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.mode = mode
}

// GetMode returns the current protocol mode.
func (s *selector) GetMode() ProtocolMode {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return s.mode
}
```

### Protocol Detection

```go
// DetectProtocol detects the protocol from message metadata.
func DetectProtocol(msg *types.Message) ProtocolMode {
    // Check security metadata
    if msg.Security != nil {
        switch msg.Security.Mode {
        case types.ProtocolModeSAGE:
            return ProtocolSAGE
        case types.ProtocolModeA2A:
            return ProtocolA2A
        }
    }

    // Default to A2A
    return ProtocolA2A
}

// IsA2AMessage checks if a message is A2A protocol.
func IsA2AMessage(msg *types.Message) bool {
    return DetectProtocol(msg) == ProtocolA2A
}

// IsSAGEMessage checks if a message is SAGE protocol.
func IsSAGEMessage(msg *types.Message) bool {
    return DetectProtocol(msg) == ProtocolSAGE
}
```

### Mock Adapter (for testing)

```go
// MockAdapter is a mock implementation for testing.
type MockAdapter struct {
    NameValue             string
    SendMessageFunc       func(ctx context.Context, msg *types.Message) error
    ReceiveMessageFunc    func(ctx context.Context) (*types.Message, error)
    VerifyFunc            func(ctx context.Context, msg *types.Message) error
    SupportsStreamingFlag bool
}

// Name returns the adapter name.
func (m *MockAdapter) Name() string {
    if m.NameValue != "" {
        return m.NameValue
    }
    return "mock"
}

// SendMessage sends a message.
func (m *MockAdapter) SendMessage(ctx context.Context, msg *types.Message) error {
    if m.SendMessageFunc != nil {
        return m.SendMessageFunc(ctx, msg)
    }
    return nil
}

// ReceiveMessage receives a message.
func (m *MockAdapter) ReceiveMessage(ctx context.Context) (*types.Message, error) {
    if m.ReceiveMessageFunc != nil {
        return m.ReceiveMessageFunc(ctx)
    }
    return nil, nil
}

// Verify verifies a message.
func (m *MockAdapter) Verify(ctx context.Context, msg *types.Message) error {
    if m.VerifyFunc != nil {
        return m.VerifyFunc(ctx, msg)
    }
    return nil
}

// SupportsStreaming returns streaming support.
func (m *MockAdapter) SupportsStreaming() bool {
    return m.SupportsStreamingFlag
}

// Stream sends streaming response.
func (m *MockAdapter) Stream(ctx context.Context, fn StreamFunc) error {
    return nil
}
```

---

## Integration with Agent

### Agent Builder Updates

```go
// In core/agent/builder.go

// WithProtocol sets the protocol mode.
func (b *builder) WithProtocol(mode protocol.ProtocolMode) Builder {
    b.agent.protocolMode = mode
    return b
}

// WithProtocolSelector sets a custom protocol selector.
func (b *builder) WithProtocolSelector(selector protocol.ProtocolSelector) Builder {
    b.agent.protocolSelector = selector
    return b
}

// WithA2AAdapter registers an A2A protocol adapter.
func (b *builder) WithA2AAdapter(adapter protocol.ProtocolAdapter) Builder {
    if b.agent.protocolSelector == nil {
        b.agent.protocolSelector = protocol.NewSelector(protocol.ProtocolAuto)
    }
    b.agent.protocolSelector.Register(protocol.ProtocolA2A, adapter)
    return b
}

// WithSAGEAdapter registers a SAGE protocol adapter.
func (b *builder) WithSAGEAdapter(adapter protocol.ProtocolAdapter) Builder {
    if b.agent.protocolSelector == nil {
        b.agent.protocolSelector = protocol.NewSelector(protocol.ProtocolAuto)
    }
    b.agent.protocolSelector.Register(protocol.ProtocolSAGE, adapter)
    return b
}
```

### Agent Process Method Updates

```go
// In core/agent/agent.go

// Process processes a message using protocol selection.
func (a *agentImpl) Process(ctx context.Context, msg *types.Message) (*types.Message, error) {
    // Select protocol adapter
    adapter := a.protocolSelector.Select(msg)

    // Verify message if SAGE protocol
    if protocol.IsSAGEMessage(msg) {
        if err := adapter.Verify(ctx, msg); err != nil {
            return nil, errors.ErrSignatureInvalid.Wrap(err)
        }
    }

    // Create message context
    msgCtx := &messageContext{
        agent:    a,
        message:  msg,
        ctx:      ctx,
        adapter:  adapter,
    }

    // Execute handler
    err := a.messageHandler(ctx, msgCtx)
    if err != nil {
        return nil, err
    }

    // Return response
    return msgCtx.response, nil
}
```

---

## Usage Examples

### Example 1: Auto Protocol Detection (Default)

```go
// Agent automatically detects protocol from incoming messages
agent := adk.NewAgent("auto").
    OnMessage(func(ctx, msg) error {
        // Protocol is automatically detected and handled
        return msg.Reply(msg.Text())
    }).
    Build()

// Processes A2A message → uses A2A protocol
a2aMsg := types.NewMessage(types.MessageRoleUser, parts)
agent.Process(ctx, a2aMsg)

// Processes SAGE message → uses SAGE protocol
sageMsg := types.NewMessage(types.MessageRoleUser, parts)
sageMsg.Security = &types.SecurityMetadata{Mode: types.ProtocolModeSAGE}
agent.Process(ctx, sageMsg)
```

### Example 2: Force Specific Protocol

```go
// Force A2A protocol only
agent := adk.NewAgent("a2a-only").
    WithProtocol(protocol.ProtocolA2A).
    OnMessage(handleMessage).
    Build()

// Force SAGE protocol only
agent := adk.NewAgent("sage-only").
    WithProtocol(protocol.ProtocolSAGE).
    OnMessage(handleMessage).
    Build()
```

### Example 3: Custom Protocol Adapter

```go
// Register custom adapter
customAdapter := &MyCustomProtocolAdapter{}

agent := adk.NewAgent("custom").
    WithProtocolSelector(protocol.NewSelector(protocol.ProtocolAuto)).
    WithA2AAdapter(a2aAdapter).
    WithSAGEAdapter(sageAdapter).
    OnMessage(handleMessage).
    Build()
```

---

## Testing Strategy

### Unit Tests

```go
func TestSelector_Select_Auto(t *testing.T) {
    selector := protocol.NewSelector(protocol.ProtocolAuto)

    a2aAdapter := &protocol.MockAdapter{NameValue: "a2a"}
    sageAdapter := &protocol.MockAdapter{NameValue: "sage"}

    selector.Register(protocol.ProtocolA2A, a2aAdapter)
    selector.Register(protocol.ProtocolSAGE, sageAdapter)

    // Test A2A message
    a2aMsg := types.NewMessage(types.MessageRoleUser, parts)
    adapter := selector.Select(a2aMsg)
    assert.Equal(t, "a2a", adapter.Name())

    // Test SAGE message
    sageMsg := types.NewMessage(types.MessageRoleUser, parts)
    sageMsg.Security = &types.SecurityMetadata{
        Mode: types.ProtocolModeSAGE,
    }
    adapter = selector.Select(sageMsg)
    assert.Equal(t, "sage", adapter.Name())
}

func TestSelector_Select_Explicit(t *testing.T) {
    selector := protocol.NewSelector(protocol.ProtocolSAGE)

    a2aAdapter := &protocol.MockAdapter{NameValue: "a2a"}
    sageAdapter := &protocol.MockAdapter{NameValue: "sage"}

    selector.Register(protocol.ProtocolA2A, a2aAdapter)
    selector.Register(protocol.ProtocolSAGE, sageAdapter)

    // Even A2A message uses SAGE adapter (forced mode)
    a2aMsg := types.NewMessage(types.MessageRoleUser, parts)
    adapter := selector.Select(a2aMsg)
    assert.Equal(t, "sage", adapter.Name())
}

func TestDetectProtocol(t *testing.T) {
    tests := []struct {
        name     string
        msg      *types.Message
        expected protocol.ProtocolMode
    }{
        {
            name:     "A2A message",
            msg:      types.NewMessage(types.MessageRoleUser, parts),
            expected: protocol.ProtocolA2A,
        },
        {
            name: "SAGE message",
            msg: &types.Message{
                Security: &types.SecurityMetadata{
                    Mode: types.ProtocolModeSAGE,
                },
            },
            expected: protocol.ProtocolSAGE,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := protocol.DetectProtocol(tt.msg)
            assert.Equal(t, tt.expected, got)
        })
    }
}
```

---

## Future Extensions

### Support for New Protocols

The adapter pattern makes it easy to add new protocols:

```go
// Example: OpenAI Assistants Protocol Adapter
type OpenAIAdapter struct {
    client *openai.Client
}

func (a *OpenAIAdapter) Name() string {
    return "openai"
}

func (a *OpenAIAdapter) SendMessage(ctx context.Context, msg *types.Message) error {
    // Convert to OpenAI format and send
    return a.client.SendMessage(ctx, convertToOpenAI(msg))
}

// Register with agent
agent.WithProtocolSelector(selector).
    Register(ProtocolOpenAI, &OpenAIAdapter{})
```

### Protocol Versioning

```go
type ProtocolVersion struct {
    Protocol string
    Version  string
}

func DetectProtocolVersion(msg *types.Message) ProtocolVersion {
    // Detect protocol version from metadata
    return ProtocolVersion{
        Protocol: "a2a",
        Version:  "1.0",
    }
}
```

---

## Implementation Order

### Phase 1: Core Interfaces
1. Define `ProtocolMode` enum
2. Define `ProtocolSelector` interface
3. Define `ProtocolAdapter` interface
4. Write comprehensive tests

### Phase 2: Implementation
1. Implement `selector` struct
2. Implement `DetectProtocol` function
3. Implement `MockAdapter` for testing
4. Unit tests for selector and detector

### Phase 3: Integration
1. Update Agent builder with protocol methods
2. Update Agent.Process to use protocol selection
3. Integration tests with Agent

### Phase 4: Adapters (Future)
1. Implement A2A adapter (wraps sage-a2a-go)
2. Implement SAGE adapter (wraps sage)
3. End-to-end tests

---

## Success Criteria

- [ ] ProtocolMode enum defined
- [ ] ProtocolSelector interface defined
- [ ] ProtocolAdapter interface defined
- [ ] Protocol detection logic implemented
- [ ] Selector implementation complete
- [ ] MockAdapter for testing
- [ ] 90%+ test coverage
- [ ] All tests passing
- [ ] Integration with Agent complete
- [ ] Documentation complete

---

## Dependencies

- `github.com/sage-x-project/sage-adk/pkg/types` - Core types
- `github.com/sage-x-project/sage-adk/pkg/errors` - Error handling
- Standard library: `context`, `sync`

Future dependencies (Phase 4):
- `github.com/sage-x-project/sage-a2a-go` - A2A adapter
- `github.com/sage-x-project/sage` - SAGE adapter

---

## Design Rationale

### Why Adapter Pattern?

Based on our AI agent research:
1. **LangChain/LangGraph**: Uses adapters for different LLM providers
2. **Google ADK**: Model-agnostic through adapter pattern
3. **Semantic Kernel**: Multiple agent types via common interface

### Why Auto-Detection?

From research insights:
1. **Developer Joy**: Users shouldn't need to configure protocol manually
2. **Progressive Disclosure**: Start simple (auto), add complexity only when needed
3. **Best Practice**: Following industry standards (LangGraph, OpenAI)

### Why Not Reinvent?

Research showed:
1. **Wrap, Don't Rewrite**: sage-a2a-go and sage are production-tested
2. **Focus on UX**: Our value is simplicity, not protocol implementation
3. **Maintainability**: Less code to maintain, easier to update

---

**Document Owner**: SAGE ADK Team
**Last Updated**: 2025-10-07 02:46:48
**Next Review**: After Phase 2 implementation
