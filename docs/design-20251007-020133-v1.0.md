# Agent Interface and Implementation Design

**Version**: 1.0
**Created**: 2025-10-07 02:01:33
**Status**: Design Phase
**Target**: core/agent

---

## Overview

This document defines the core Agent interface and implementation for SAGE ADK, designed to dramatically simplify AI agent development while maintaining full protocol support (A2A and SAGE).

### Design Goals

1. **Simplicity**: 5-10 lines for basic agents (vs current 100+)
2. **Progressive Disclosure**: Start simple, add complexity as needed
3. **Type Safety**: Compile-time validation
4. **Developer Joy**: Make common tasks trivial, advanced tasks possible
5. **Production Ready**: Built-in resilience, observability, security

### Success Metrics

| Agent Type | Current (sage-a2a-go) | Target (SAGE ADK) | Reduction |
|-----------|----------------------|------------------|-----------|
| Simple echo | 100+ lines | 5-10 lines | 90% |
| LLM chat | 120+ lines | 10-15 lines | 90% |
| Streaming | 150+ lines | 15-20 lines | 87% |
| SAGE secure | 200+ lines | 15-20 lines | 90% |
| Production | 250+ lines | 30-40 lines | 84% |

---

## Design Principles

### 1. Message-Centric API

All agent interaction happens through a rich `Message` context object:

```go
type MessageContext interface {
    // Content access
    Text() string
    Parts() []types.Part
    ContextID() string
    MessageID() string

    // Response helpers
    Reply(text string) error
    ReplyWithParts(parts []types.Part) error
    Stream(fn StreamFunc) error

    // LLM access (if configured)
    LLM() LLMClient

    // State access (if configured)
    State() State
    History() []types.Message

    // Tool access (if configured)
    CallTool(name string, params map[string]any) (any, error)

    // Protocol info
    Protocol() ProtocolMode
    Security() *types.SecurityMetadata
}
```

### 2. Builder Pattern

Fluent, chainable API with validation at `Build()`:

```go
agent := adk.NewAgent("my-agent").
    WithDescription("AI assistant").
    WithLLM(llm.OpenAI()).
    WithProtocol(adk.ProtocolAuto).
    OnMessage(handleMessage).
    Build()
```

### 3. Convention Over Configuration

Sensible defaults minimize boilerplate:

```go
// Minimal configuration
agent := adk.NewAgent("simple").
    OnMessage(handler).
    Build()

// Defaults:
// - Protocol: A2A
// - Storage: Memory
// - Port: 8080
// - Logging: JSON, INFO level
// - Protocol detection: Auto
```

### 4. Progressive Disclosure

Start simple, add features incrementally:

```go
// Level 1: Echo (5 lines)
adk.NewAgent("echo").OnMessage(func(ctx, msg) error {
    return msg.Reply(msg.Text())
}).Start(":8080")

// Level 2: LLM (10 lines)
adk.NewAgent("chat").WithLLM(llm.OpenAI()).OnMessage(func(ctx, msg) error {
    response, _ := msg.LLM().Generate(ctx, msg.Text())
    return msg.Reply(response)
}).Start(":8080")

// Level 3: Streaming (15 lines)
adk.NewAgent("stream").WithLLM(llm.OpenAI()).OnMessage(func(ctx, msg) error {
    return msg.LLM().GenerateStream(ctx, msg.Text(), msg.SendChunk)
}).Start(":8080")

// Level 4: Production (40 lines)
agent := adk.NewAgent("production").
    WithLLM(llm.FromEnv()).
    WithProtocol(adk.ProtocolAuto).
    WithSAGE(sage.Optional()).
    WithStorage(storage.Redis(client)).
    WithRetry(retry.Exponential(3, time.Second)).
    WithMetrics(metrics.Prometheus()).
    OnMessage(handleMessage).
    Build()
```

---

## Core Interfaces

### Agent Interface

```go
// Agent represents an AI agent instance.
type Agent interface {
    // Identity
    Name() string
    Description() string
    Card() *types.AgentCard

    // Lifecycle
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
    Health() HealthStatus

    // Message processing
    Process(ctx context.Context, msg *types.Message) (*types.Message, error)
    ProcessStream(ctx context.Context, msg *types.Message) (StreamReader, error)

    // Configuration
    Config() *config.Config

    // Observability
    Metrics() Metrics
    Logger() Logger
}
```

### MessageHandler Interface

```go
// MessageHandler processes incoming messages.
type MessageHandler func(ctx context.Context, msg MessageContext) error

// StreamFunc handles streaming responses.
type StreamFunc func(stream Stream) error

// Stream provides streaming response interface.
type Stream interface {
    Send(text string) error
    SendPart(part types.Part) error
    Close() error
}
```

### Builder Interface

```go
// Builder constructs agents with fluent API.
type Builder interface {
    // Identity
    WithName(name string) Builder
    WithDescription(desc string) Builder
    WithVersion(version string) Builder

    // Protocol
    WithProtocol(mode ProtocolMode) Builder
    WithA2A(opts A2AOptions) Builder
    WithSAGE(opts SAGEOptions) Builder

    // LLM
    WithLLM(provider LLMProvider) Builder
    WithLLMFromEnv() Builder

    // Storage
    WithStorage(storage Storage) Builder
    WithMemoryStorage() Builder
    WithRedisStorage(client *redis.Client) Builder

    // Tools
    WithTool(tool Tool) Builder
    WithTools(tools ...Tool) Builder

    // Handlers
    OnMessage(handler MessageHandler) Builder
    OnError(handler ErrorHandler) Builder
    OnStart(handler LifecycleHandler) Builder
    OnStop(handler LifecycleHandler) Builder

    // Middleware
    Use(middleware ...Middleware) Builder

    // Resilience
    WithRetry(policy RetryPolicy) Builder
    WithTimeout(timeout time.Duration) Builder
    WithCircuitBreaker(breaker CircuitBreaker) Builder

    // Observability
    WithMetrics(metrics Metrics) Builder
    WithLogger(logger Logger) Builder

    // Server
    WithServer(server Server) Builder
    WithPort(port int) Builder

    // Build and run
    Build() (Agent, error)
    Start(addr string) error  // Convenience: Build() + agent.Start()
}
```

---

## Implementation Design

### Package Structure

```
core/agent/
├── doc.go              # Package documentation
├── agent.go            # Agent interface and base implementation
├── agent_test.go       # Agent tests
├── builder.go          # Builder implementation
├── builder_test.go     # Builder tests
├── message.go          # MessageContext implementation
├── message_test.go     # Message context tests
├── handlers.go         # Handler types and helpers
├── handlers_test.go    # Handler tests
└── options.go          # Configuration options
```

### Agent Implementation

```go
// agent represents the core agent implementation.
type agent struct {
    // Identity
    name        string
    description string
    version     string

    // Configuration
    config *config.Config

    // Protocol handlers
    protocol     ProtocolMode
    a2aAdapter   *adapters.A2AAdapter
    sageAdapter  *adapters.SAGEAdapter

    // LLM
    llm LLMProvider

    // Storage
    storage Storage

    // Tools
    tools *ToolRegistry

    // Handlers
    messageHandler MessageHandler
    errorHandler   ErrorHandler

    // Middleware
    middleware []Middleware

    // Server
    server Server

    // Resilience
    retry   RetryPolicy
    timeout time.Duration
    breaker CircuitBreaker

    // Observability
    metrics Metrics
    logger  Logger

    // Lifecycle
    mu      sync.RWMutex
    running bool
    done    chan struct{}
}
```

### Builder Implementation

```go
// builder implements the Builder interface.
type builder struct {
    agent *agent
    err   error  // Accumulate errors
}

// NewAgent creates a new agent builder.
func NewAgent(name string) Builder {
    return &builder{
        agent: &agent{
            name:    name,
            version: "0.1.0",
            config:  config.DefaultConfig(),
            logger:  logger.Default(),
            metrics: metrics.NoOp(),
        },
    }
}

// Build validates configuration and constructs the agent.
func (b *builder) Build() (Agent, error) {
    if b.err != nil {
        return nil, b.err
    }

    // Validation
    if b.agent.name == "" {
        return nil, errors.ErrMissingField.WithDetail("field", "name")
    }

    if b.agent.messageHandler == nil {
        return nil, errors.ErrMissingField.WithDetail("field", "message_handler")
    }

    // Set defaults
    if b.agent.protocol == ProtocolUnknown {
        b.agent.protocol = ProtocolAuto
    }

    if b.agent.storage == nil {
        b.agent.storage = storage.NewMemory()
    }

    if b.agent.server == nil {
        b.agent.server = server.NewHTTP(b.agent.config.Server)
    }

    // Initialize protocol adapters
    if err := b.initializeProtocols(); err != nil {
        return nil, err
    }

    return b.agent, nil
}

// Start is a convenience method: Build() + Start()
func (b *builder) Start(addr string) error {
    agent, err := b.Build()
    if err != nil {
        return err
    }

    // Parse address
    host, port := parseAddress(addr)
    b.agent.config.Server.Host = host
    b.agent.config.Server.Port = port

    return agent.Start(context.Background())
}
```

### MessageContext Implementation

```go
// messageContext implements MessageContext.
type messageContext struct {
    agent   *agent
    message *types.Message
    ctx     context.Context

    // Response handling
    responseSent bool
    streaming    bool
}

// Reply sends a text response.
func (m *messageContext) Reply(text string) error {
    if m.responseSent {
        return errors.ErrInternal.WithMessage("response already sent")
    }

    parts := []types.Part{types.NewTextPart(text)}
    return m.ReplyWithParts(parts)
}

// ReplyWithParts sends a response with multiple parts.
func (m *messageContext) ReplyWithParts(parts []types.Part) error {
    if m.responseSent {
        return errors.ErrInternal.WithMessage("response already sent")
    }

    response := types.NewMessage(types.MessageRoleAgent, parts)
    response.ContextID = m.message.ContextID

    // Send through protocol adapter
    switch m.agent.protocol {
    case ProtocolA2A, ProtocolAuto:
        return m.agent.a2aAdapter.SendMessage(m.ctx, response)
    case ProtocolSAGE:
        return m.agent.sageAdapter.SendMessage(m.ctx, response)
    default:
        return errors.ErrProtocolMismatch
    }

    m.responseSent = true
    return nil
}

// Stream handles streaming responses.
func (m *messageContext) Stream(fn StreamFunc) error {
    if m.responseSent {
        return errors.ErrInternal.WithMessage("response already sent")
    }

    m.streaming = true
    stream := newStream(m.agent, m.ctx, m.message)

    // Execute stream function
    err := fn(stream)

    // Close stream
    closeErr := stream.Close()
    if err != nil {
        return err
    }

    m.responseSent = true
    return closeErr
}

// LLM returns the LLM client if configured.
func (m *messageContext) LLM() LLMClient {
    if m.agent.llm == nil {
        panic("LLM not configured. Use WithLLM() in builder.")
    }
    return m.agent.llm
}

// State returns the state storage.
func (m *messageContext) State() State {
    return m.agent.storage.State(m.message.ContextID)
}

// History returns conversation history.
func (m *messageContext) History() []types.Message {
    return m.agent.storage.History(m.message.ContextID)
}
```

---

## Protocol Integration

### Protocol Modes

```go
type ProtocolMode int

const (
    ProtocolUnknown ProtocolMode = iota
    ProtocolA2A                  // A2A only
    ProtocolSAGE                 // SAGE only
    ProtocolAuto                 // Auto-detect from message
)
```

### Auto-Detection

```go
// detectProtocol determines protocol from message metadata.
func (a *agent) detectProtocol(msg *types.Message) ProtocolMode {
    if msg.Security != nil && msg.Security.Mode == types.ProtocolModeSAGE {
        return ProtocolSAGE
    }
    return ProtocolA2A
}

// Process handles incoming message with protocol detection.
func (a *agent) Process(ctx context.Context, msg *types.Message) (*types.Message, error) {
    protocol := a.protocol

    // Auto-detect if configured
    if protocol == ProtocolAuto {
        protocol = a.detectProtocol(msg)
    }

    // Verify SAGE signature if present
    if protocol == ProtocolSAGE {
        if err := a.sageAdapter.VerifySignature(ctx, msg); err != nil {
            return nil, errors.ErrSignatureInvalid.Wrap(err)
        }
    }

    // Store message in history
    if err := a.storage.AppendMessage(msg.GetContextID(), msg); err != nil {
        a.logger.Warn("failed to store message", "error", err)
    }

    // Create message context
    msgCtx := &messageContext{
        agent:   a,
        message: msg,
        ctx:     ctx,
    }

    // Apply middleware
    handler := a.messageHandler
    for i := len(a.middleware) - 1; i >= 0; i-- {
        handler = a.middleware[i](handler)
    }

    // Execute handler with retry
    err := a.executeWithRetry(ctx, func() error {
        return handler(ctx, msgCtx)
    })

    if err != nil {
        if a.errorHandler != nil {
            a.errorHandler(ctx, err)
        }
        return nil, err
    }

    // Response already sent via msgCtx
    return nil, nil
}
```

---

## LLM Integration

### LLM Client Interface

```go
// LLMClient provides LLM operations.
type LLMClient interface {
    // Generate creates a text response.
    Generate(ctx context.Context, prompt string, opts ...LLMOption) (string, error)

    // GenerateWithHistory creates a response using conversation history.
    GenerateWithHistory(ctx context.Context, prompt string, history []types.Message, opts ...LLMOption) (string, error)

    // GenerateStream creates a streaming response.
    GenerateStream(ctx context.Context, prompt string, callback func(chunk string) error, opts ...LLMOption) error

    // GenerateWithTools creates a response with tool calling.
    GenerateWithTools(ctx context.Context, prompt string, tools []Tool, opts ...LLMOption) (string, []ToolCall, error)
}

// LLMOption configures LLM behavior.
type LLMOption func(*LLMOptions)

type LLMOptions struct {
    MaxTokens   int
    Temperature float64
    TopP        float64
    Stop        []string
}
```

### Usage in Handlers

```go
// Simple LLM usage
func handleMessage(ctx context.Context, msg MessageContext) error {
    response, err := msg.LLM().Generate(ctx, msg.Text())
    if err != nil {
        return err
    }
    return msg.Reply(response)
}

// With history
func handleWithHistory(ctx context.Context, msg MessageContext) error {
    history := msg.History()
    response, err := msg.LLM().GenerateWithHistory(ctx, msg.Text(), history)
    if err != nil {
        return err
    }
    return msg.Reply(response)
}

// Streaming
func handleStreaming(ctx context.Context, msg MessageContext) error {
    return msg.LLM().GenerateStream(ctx, msg.Text(), func(chunk string) error {
        return msg.SendChunk(chunk)
    })
}
```

---

## Tool Integration

### Tool Interface

```go
// Tool represents an executable capability.
type Tool interface {
    Name() string
    Description() string
    Parameters() Schema
    Execute(ctx context.Context, params map[string]any) (any, error)
}

// Schema defines tool parameter structure.
type Schema struct {
    Type       string
    Properties map[string]Property
    Required   []string
}

// Property defines a parameter property.
type Property struct {
    Type        string
    Description string
    Enum        []string
}
```

### Tool Registry

```go
// ToolRegistry manages available tools.
type ToolRegistry struct {
    tools map[string]Tool
}

// Register adds a tool to the registry.
func (r *ToolRegistry) Register(tool Tool) {
    r.tools[tool.Name()] = tool
}

// Get retrieves a tool by name.
func (r *ToolRegistry) Get(name string) (Tool, bool) {
    tool, ok := r.tools[name]
    return tool, ok
}

// All returns all registered tools.
func (r *ToolRegistry) All() []Tool {
    tools := make([]Tool, 0, len(r.tools))
    for _, tool := range r.tools {
        tools = append(tools, tool)
    }
    return tools
}
```

### Usage

```go
// Define tool
type CalculatorTool struct{}

func (t *CalculatorTool) Name() string { return "calculator" }
func (t *CalculatorTool) Description() string {
    return "Evaluate mathematical expressions"
}
func (t *CalculatorTool) Parameters() Schema {
    return Schema{
        Type: "object",
        Properties: map[string]Property{
            "expression": {
                Type:        "string",
                Description: "Math expression to evaluate",
            },
        },
        Required: []string{"expression"},
    }
}
func (t *CalculatorTool) Execute(ctx context.Context, params map[string]any) (any, error) {
    expr := params["expression"].(string)
    result, err := eval(expr)
    return result, err
}

// Register with agent
agent := adk.NewAgent("tools").
    WithLLM(llm.OpenAI()).
    WithTool(&CalculatorTool{}).
    OnMessage(func(ctx, msg) error {
        // LLM can automatically call tools
        response, _ := msg.LLM().GenerateWithTools(ctx, msg.Text(), msg.Tools())
        return msg.Reply(response)
    }).
    Build()
```

---

## State Management

### State Interface

```go
// State provides key-value storage scoped to a context.
type State interface {
    // Get retrieves a value.
    Get(key string) (any, error)

    // Set stores a value.
    Set(key string, value any) error

    // Delete removes a value.
    Delete(key string) error

    // Keys returns all keys.
    Keys() ([]string, error)
}

// Storage provides state and history management.
type Storage interface {
    // State returns a context-scoped state.
    State(contextID string) State

    // AppendMessage adds a message to history.
    AppendMessage(contextID string, msg *types.Message) error

    // History retrieves conversation history.
    History(contextID string) []types.Message

    // ClearHistory removes all messages for a context.
    ClearHistory(contextID string) error
}
```

### Usage

```go
func handleStateful(ctx context.Context, msg MessageContext) error {
    // Get user state
    state := msg.State()
    count, _ := state.Get("message_count")
    if count == nil {
        count = 0
    }

    // Increment
    count = count.(int) + 1
    state.Set("message_count", count)

    // Use in response
    response := fmt.Sprintf("This is message #%d", count)
    return msg.Reply(response)
}
```

---

## Middleware

### Middleware Interface

```go
// Middleware wraps message handlers.
type Middleware func(MessageHandler) MessageHandler
```

### Built-in Middleware

```go
// Logging middleware
func Logging(logger Logger) Middleware {
    return func(next MessageHandler) MessageHandler {
        return func(ctx context.Context, msg MessageContext) error {
            logger.Info("message received",
                "message_id", msg.MessageID(),
                "context_id", msg.ContextID(),
            )

            start := time.Now()
            err := next(ctx, msg)
            duration := time.Since(start)

            if err != nil {
                logger.Error("message failed",
                    "error", err,
                    "duration", duration,
                )
            } else {
                logger.Info("message processed",
                    "duration", duration,
                )
            }

            return err
        }
    }
}

// Rate limiting middleware
func RateLimit(limit int, window time.Duration) Middleware {
    limiter := rate.NewLimiter(rate.Every(window/time.Duration(limit)), limit)

    return func(next MessageHandler) MessageHandler {
        return func(ctx context.Context, msg MessageContext) error {
            if !limiter.Allow() {
                return errors.ErrInternal.WithMessage("rate limit exceeded")
            }
            return next(ctx, msg)
        }
    }
}

// Authentication middleware
func Authentication(verify func(msg MessageContext) error) Middleware {
    return func(next MessageHandler) MessageHandler {
        return func(ctx context.Context, msg MessageContext) error {
            if err := verify(msg); err != nil {
                return errors.ErrUnauthorized.Wrap(err)
            }
            return next(ctx, msg)
        }
    }
}
```

### Usage

```go
agent := adk.NewAgent("middleware").
    Use(
        middleware.Logging(logger),
        middleware.RateLimit(100, time.Minute),
        middleware.Authentication(verifyToken),
    ).
    OnMessage(handleMessage).
    Build()
```

---

## Error Handling

### Error Handler

```go
// ErrorHandler processes errors.
type ErrorHandler func(ctx context.Context, err error)

// Default error handler logs errors.
func defaultErrorHandler(logger Logger) ErrorHandler {
    return func(ctx context.Context, err error) {
        logger.Error("agent error", "error", err)
    }
}
```

### Usage

```go
agent := adk.NewAgent("errors").
    OnError(func(ctx context.Context, err error) {
        // Custom error handling
        logger.Error("agent failed", "error", err)
        metrics.IncrementErrorCount()

        // Alert on critical errors
        if isCritical(err) {
            alert.Send(err)
        }
    }).
    OnMessage(handleMessage).
    Build()
```

---

## Resilience Patterns

### Retry Policy

```go
// RetryPolicy defines retry behavior.
type RetryPolicy struct {
    MaxAttempts  int
    InitialDelay time.Duration
    MaxDelay     time.Duration
    Strategy     RetryStrategy
}

type RetryStrategy int

const (
    RetryConstant RetryStrategy = iota
    RetryExponential
    RetryFibonacci
)

// executeWithRetry executes a function with retry logic.
func (a *agent) executeWithRetry(ctx context.Context, fn func() error) error {
    if a.retry.MaxAttempts == 0 {
        return fn()
    }

    var lastErr error
    delay := a.retry.InitialDelay

    for attempt := 0; attempt < a.retry.MaxAttempts; attempt++ {
        err := fn()
        if err == nil {
            return nil
        }

        lastErr = err

        // Don't retry on certain errors
        if !isRetryable(err) {
            return err
        }

        // Wait before retry
        if attempt < a.retry.MaxAttempts-1 {
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-time.After(delay):
            }

            // Calculate next delay
            delay = a.calculateNextDelay(delay, attempt)
        }
    }

    return lastErr
}
```

### Circuit Breaker

```go
// CircuitBreaker prevents cascading failures.
type CircuitBreaker struct {
    FailureThreshold int
    Timeout          time.Duration
    ResetTimeout     time.Duration

    state        BreakerState
    failures     int
    lastFailTime time.Time
    mu           sync.RWMutex
}

type BreakerState int

const (
    BreakerClosed BreakerState = iota
    BreakerOpen
    BreakerHalfOpen
)

// Execute runs a function through the circuit breaker.
func (b *CircuitBreaker) Execute(fn func() error) error {
    b.mu.RLock()
    state := b.state
    b.mu.RUnlock()

    switch state {
    case BreakerOpen:
        // Check if reset timeout elapsed
        if time.Since(b.lastFailTime) > b.ResetTimeout {
            b.transitionTo(BreakerHalfOpen)
        } else {
            return errors.ErrInternal.WithMessage("circuit breaker open")
        }
    }

    err := fn()

    if err != nil {
        b.recordFailure()
    } else {
        b.recordSuccess()
    }

    return err
}
```

---

## Testing Strategy

### Unit Tests

```go
func TestAgent_ProcessMessage(t *testing.T) {
    mockLLM := &MockLLM{response: "Hello!"}

    agent := adk.NewAgent("test").
        WithLLM(mockLLM).
        OnMessage(func(ctx, msg) error {
            response, _ := msg.LLM().Generate(ctx, msg.Text())
            return msg.Reply(response)
        }).
        Build()

    msg := types.NewMessage(types.MessageRoleUser, []types.Part{
        types.NewTextPart("Hi"),
    })

    response, err := agent.Process(context.Background(), msg)
    assert.NoError(t, err)
    assert.Equal(t, "Hello!", extractText(response))
}

func TestAgent_Streaming(t *testing.T) {
    chunks := []string{"Hello", " ", "World"}
    mockLLM := &MockStreamingLLM{chunks: chunks}

    agent := adk.NewAgent("test").
        WithLLM(mockLLM).
        OnMessage(func(ctx, msg) error {
            return msg.Stream(func(s Stream) error {
                for _, chunk := range chunks {
                    s.Send(chunk)
                }
                return nil
            })
        }).
        Build()

    msg := types.NewMessage(types.MessageRoleUser, []types.Part{
        types.NewTextPart("Hi"),
    })

    reader, err := agent.ProcessStream(context.Background(), msg)
    assert.NoError(t, err)

    var result strings.Builder
    for chunk := range reader.Read() {
        result.WriteString(chunk)
    }

    assert.Equal(t, "Hello World", result.String())
}
```

---

## Examples

### Example 1: Simple Echo Agent (5 lines)

```go
adk.NewAgent("echo").
    OnMessage(func(ctx, msg) error {
        return msg.Reply(msg.Text())
    }).
    Start(":8080")
```

### Example 2: LLM Chat Agent (10 lines)

```go
adk.NewAgent("chat").
    WithLLM(llm.OpenAI()).
    OnMessage(func(ctx, msg) error {
        response, err := msg.LLM().Generate(ctx, msg.Text())
        if err != nil {
            return err
        }
        return msg.Reply(response)
    }).
    Start(":8080")
```

### Example 3: Streaming Agent (15 lines)

```go
adk.NewAgent("streaming").
    WithLLM(llm.OpenAI()).
    OnMessage(func(ctx, msg) error {
        return msg.LLM().GenerateStream(
            ctx,
            msg.Text(),
            func(chunk string) error {
                return msg.SendChunk(chunk)
            },
        )
    }).
    Start(":8080")
```

### Example 4: SAGE-Secured Agent (20 lines)

```go
adk.NewAgent("secure").
    WithProtocol(adk.ProtocolSAGE).
    WithSAGE(sage.Options{
        DID:     os.Getenv("SAGE_DID"),
        Network: sage.NetworkEthereum,
    }).
    WithLLM(llm.OpenAI()).
    OnMessage(func(ctx, msg) error {
        // Message already verified via SAGE
        response, err := msg.LLM().Generate(ctx, msg.Text())
        if err != nil {
            return err
        }
        return msg.Reply(response)
    }).
    Start(":8080")
```

### Example 5: Production Agent (40 lines)

```go
func main() {
    // Redis client
    rdb := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })

    // Build agent
    agent, err := adk.NewAgent("production").
        WithDescription("Production AI assistant").
        WithProtocol(adk.ProtocolAuto).
        WithSAGE(sage.Optional()).
        WithLLM(llm.FromEnv()).
        WithStorage(storage.Redis(rdb)).
        WithRetry(retry.Exponential(3, time.Second)).
        WithTimeout(30 * time.Second).
        WithCircuitBreaker(breaker.Default()).
        WithMetrics(metrics.Prometheus()).
        WithLogger(logger.JSON()).
        Use(
            middleware.Logging(),
            middleware.RateLimit(100, time.Minute),
        ).
        OnMessage(handleMessage).
        OnError(handleError).
        OnStart(func() error {
            logger.Info("agent starting")
            return nil
        }).
        OnStop(func() error {
            logger.Info("agent stopping")
            return rdb.Close()
        }).
        Build()

    if err != nil {
        log.Fatal(err)
    }

    // Start agent
    if err := agent.Start(context.Background()); err != nil {
        log.Fatal(err)
    }
}

func handleMessage(ctx context.Context, msg MessageContext) error {
    history := msg.History()
    response, err := msg.LLM().GenerateWithHistory(ctx, msg.Text(), history)
    if err != nil {
        return err
    }
    return msg.Reply(response)
}

func handleError(ctx context.Context, err error) {
    logger.Error("agent error", "error", err)
    metrics.IncrementErrorCount()
}
```

---

## Implementation Order

### Phase 1: Core Interfaces
1. Define Agent, Builder, MessageContext interfaces
2. Define handler types (MessageHandler, ErrorHandler, etc.)
3. Define options and configuration structs

### Phase 2: Basic Implementation
1. Implement builder with validation
2. Implement basic agent struct
3. Implement messageContext with Reply()
4. Basic message processing (no protocol yet)

### Phase 3: Testing
1. Unit tests for builder
2. Unit tests for message handling
3. Mock implementations for testing

### Phase 4: Protocol Integration (Next Phase)
1. Integrate A2A adapter
2. Integrate SAGE adapter
3. Protocol auto-detection
4. End-to-end tests

---

## Success Criteria

- [ ] Builder API implemented with fluent interface
- [ ] Agent can process basic messages
- [ ] MessageContext provides Reply() functionality
- [ ] Error handling properly structured
- [ ] 90%+ test coverage
- [ ] All tests passing
- [ ] Example agents work as designed
- [ ] Documentation complete

---

## Dependencies

- `github.com/sage-x-project/sage-adk/pkg/types` - Core types
- `github.com/sage-x-project/sage-adk/pkg/errors` - Error handling
- `github.com/sage-x-project/sage-adk/config` - Configuration
- Standard library: `context`, `sync`, `time`

Future dependencies (Phase 4):
- `github.com/sage-x-project/sage-a2a-go` - A2A protocol
- `github.com/sage-x-project/sage` - SAGE protocol
- `github.com/redis/go-redis/v9` - Redis (optional)

---

**Document Owner**: SAGE ADK Team
**Last Updated**: 2025-10-07 02:01:33
**Next Review**: After Phase 2 implementation
