# SAGE Adapter Design Document

**Version**: 1.0
**Created**: 2025-10-07
**Author**: SAGE ADK Development Team

## Overview

This document describes the design for the SAGE (Secure Agent Guarantee Engine) protocol adapter, which wraps the `sage` library to provide SAGE protocol support with full security features including DID, cryptographic signing, and RFC-9421 compliance.

## Design Principles

Based on AI agent development research:
- **Adapter Pattern**: Wrap sage library without reimplementation
- **Security First**: Maintain all SAGE security guarantees
- **Progressive Disclosure**: Complex security made simple
- **Zero Trust**: Verify all messages by default

## Architecture

### SAGE vs A2A Comparison

| Feature | A2A | SAGE |
|---------|-----|------|
| Security | Optional | Built-in (DID + Signatures) |
| Message Format | Simple JSON | RFC-9421 signed messages |
| Authentication | Token-based | DID-based with blockchain |
| Verification | Client-side | On-chain DID resolution |
| Complexity | Low | High |

### SAGE Adapter Components

```
SAGE Adapter
├── Core Integration (sage/core)
│   ├── DID Manager (did.Manager)
│   ├── Crypto Manager (crypto.Manager)
│   └── Verification Service (VerificationService)
├── Message Handling
│   ├── RFC-9421 Message Builder
│   ├── Signature Generation
│   └── Message Verification
└── Type Conversion
    ├── sage-adk Message ↔ SAGE Message
    └── Security Metadata handling
```

## Implementation Strategy

### Phase 1: Core Initialization (Minimal Viable Adapter)

Create basic SAGE adapter that can:
- Initialize sage Core
- Sign messages with DID
- Verify messages from other agents

**NOT included in Phase 1:**
- Full type conversion (keep it simple)
- Streaming support
- Advanced DID operations (registration, update)

### Phase 2: Message Signing & Verification

Implement core security features:
- Sign outgoing messages with agent's DID
- Verify incoming messages against DID registry
- Handle nonce and timestamp
- Manage key rotation

### Phase 3: Full Integration

Add advanced features:
- Complete type conversion
- DID lifecycle management
- Multi-chain support
- Storage integration

## Simplified Implementation Plan

### Step 1: Basic Adapter Structure

```go
type Adapter struct {
    core      *core.Core           // SAGE core instance
    config    *config.SAGEConfig   // SAGE configuration
    agentDID  string               // This agent's DID
    keyPair   crypto.KeyPair       // Signing key pair
    mu        sync.RWMutex         // Thread safety
}
```

### Step 2: Configuration

Required configuration:

```yaml
sage:
  enabled: true
  network: "ethereum"  # or "kaia", "sepolia"
  did: "did:sage:eth:0x..."
  key_path: "/path/to/keys"
  registry_contract: "0x..."
```

### Step 3: Core Operations

**SendMessage** (simplified):
```go
func (a *Adapter) SendMessage(ctx context.Context, msg *types.Message) error {
    // 1. Convert to bytes
    msgBytes, _ := json.Marshal(msg)

    // 2. Sign with RFC-9421
    builder := a.core.CreateRFC9421Message(a.agentDID, msgBytes)
    signature, _ := a.core.SignMessage(a.keyPair, msgBytes)

    // 3. Add security metadata
    msg.Security = &types.SecurityMetadata{
        Mode:      types.ProtocolModeSAGE,
        AgentDID:  a.agentDID,
        Signature: signature,
        Timestamp: time.Now(),
    }

    // 4. Send (implementation TBD - need SAGE transport layer)
    return nil
}
```

**ReceiveMessage** (simplified):
```go
func (a *Adapter) ReceiveMessage(ctx context.Context) (*types.Message, error) {
    // Receive from SAGE network (implementation TBD)
    return nil, errors.ErrNotImplemented
}
```

**Verify**:
```go
func (a *Adapter) Verify(ctx context.Context, msg *types.Message) error {
    if msg.Security == nil {
        return errors.ErrInvalidInput.WithMessage("missing security metadata")
    }

    // Verify signature using SAGE core
    return a.core.QuickVerify(
        ctx,
        msg.Security.AgentDID,
        msgBytes,
        msg.Security.Signature,
    )
}
```

## Challenges & Solutions

### Challenge 1: SAGE Transport Layer

**Problem**: SAGE library doesn't have built-in network transport like A2A does.

**Solution**:
- Phase 1: Return ErrNotImplemented for SendMessage/ReceiveMessage
- Focus on Verify() which is usable standalone
- Future: Implement gRPC or HTTP transport layer

### Challenge 2: Complex DID Lifecycle

**Problem**: DID registration requires blockchain transactions, gas fees, etc.

**Solution**:
- Assume DID is already registered (provided in config)
- Focus on message verification, not DID management
- Future: Add DID registration helper functions

### Challenge 3: Key Management

**Problem**: Secure key storage and rotation.

**Solution**:
- Use sage crypto.Manager for key operations
- Support file-based key storage initially
- Future: Vault integration

### Challenge 4: Type Conversion Complexity

**Problem**: SAGE uses RFC-9421 message format, very different from A2A.

**Solution**:
- Don't convert types in Phase 1
- Store sage-adk Message as JSON in RFC-9421 body
- Add proper conversion in Phase 2

## Minimal Implementation Scope

For initial implementation, focus on:

1. ✅ **Basic Adapter**: Name(), SupportsStreaming()
2. ✅ **Verification**: Verify() using SAGE core
3. ✅ **Configuration**: Load SAGE config
4. ⏳ **Initialization**: Initialize SAGE core with DID
5. ❌ **SendMessage**: Return ErrNotImplemented (no transport)
6. ❌ **ReceiveMessage**: Return ErrNotImplemented (no transport)
7. ❌ **Streaming**: Return ErrNotImplemented

This allows Protocol Selector to work, but actual message sending requires transport layer implementation.

## Testing Strategy

1. **Unit Tests**: Test adapter initialization and config
2. **Verification Tests**: Test signature verification (mock)
3. **Integration Tests**: Skip for now (requires blockchain)

## Dependencies

```go
require (
    github.com/sage-x-project/sage v0.0.0
)
```

## Future Enhancements

1. **Transport Layer**: Implement gRPC/HTTP for SAGE messaging
2. **DID Management**: Add registration, update, deactivation
3. **Key Rotation**: Automated key rotation
4. **Multi-chain**: Support multiple blockchain networks
5. **Handshake**: Implement SAGE handshake protocol
6. **Storage**: Persistent message and DID cache

## Decision: Simplified Scope

Given complexity, **Phase 1** will implement:
- Basic adapter structure
- Configuration loading
- Verification only (no send/receive)
- Return ErrNotImplemented for unimplemented features

This allows us to:
- Complete the adapter interface
- Support protocol detection
- Enable verification in receivers
- Defer complex transport implementation

## References

- SAGE Library: `/sage/` directory
- RFC-9421 Specification: HTTP Message Signatures
- DID Specification: W3C Decentralized Identifiers
- Protocol Layer Design: `docs/design-20251007-024648-v1.0.md`
