# Core Type Definitions Design

**Version**: 1.0
**Created**: 2025-10-07 00:15:10
**Status**: Design Phase
**Target**: pkg/types/

---

## Overview

This document defines the core type system for SAGE ADK, designed to support both A2A and SAGE protocols with seamless interoperability. The type system must be:

1. **Protocol Agnostic**: Core types work with both A2A and SAGE
2. **Extensible**: Easy to add new protocols or features
3. **Type Safe**: Strong typing with minimal interface{} usage
4. **Conversion Friendly**: Easy conversion between A2A and ADK types
5. **Validation Ready**: Built-in validation support

---

## Reference Implementations

### A2A Protocol (sage-a2a-go/protocol/types.go)
- **Message**: Role-based (user/agent) with Parts (text/file/data)
- **Task**: Stateful with lifecycle (submitted → working → completed)
- **Part Interface**: Polymorphic content (TextPart, FilePart, DataPart)
- **TaskState**: String-based states (submitted, working, completed, etc.)
- **Artifact**: Task output with Parts
- **Events**: TaskStatusUpdateEvent, TaskArtifactUpdateEvent

### SAGE Security (sage/core/message/types.go)
- **MessageControlHeader**: Sequence, Nonce, Timestamp for replay protection
- **BaseMessage**: ContextID for message correlation

### SAGE Security (sage/core/rfc9421/types.go)
- **Message**: AgentDID, MessageID, Timestamp, Nonce, Signature metadata
- **SignatureAlgorithm**: EdDSA, ES256K, ECDSA, ECDSA-secp256k1

### SAGE DID (sage/did/types.go)
- **AgentDID**: Decentralized identifier string
- **AgentMetadata**: DID, Name, Endpoint, PublicKey, Capabilities, Owner
- **Chain/Network**: Blockchain network types (Ethereum, Kaia, Solana)

---

## Design Principles

### 1. Unified Message Type
Create a single `Message` type that can represent both A2A and SAGE messages by including optional security fields.

```go
type Message struct {
    // A2A Core Fields
    MessageID    string
    ContextID    *string
    Role         MessageRole
    Parts        []Part
    Kind         string
    Metadata     map[string]interface{}

    // A2A Optional Fields
    TaskID           *string
    ReferenceTaskIDs []string
    Extensions       []string

    // SAGE Security Fields (optional)
    Security *SecurityMetadata
}
```

### 2. Security Metadata Separation
Keep security-related fields in a separate struct to maintain clean separation:

```go
type SecurityMetadata struct {
    Mode      ProtocolMode  // "a2a", "sage", "auto"
    AgentDID  string
    Nonce     string
    Timestamp time.Time
    Sequence  uint64
    Signature *SignatureData
}

type SignatureData struct {
    Algorithm    string
    KeyID        string
    Signature    []byte
    SignedFields []string
}
```

### 3. Protocol Mode Enum
Clear protocol selection mechanism:

```go
type ProtocolMode string

const (
    ProtocolModeA2A   ProtocolMode = "a2a"
    ProtocolModeSAGE  ProtocolMode = "sage"
    ProtocolModeAuto  ProtocolMode = "auto"
)
```

### 4. Agent Metadata
Unified agent information supporting both protocols:

```go
type Agent struct {
    ID           string
    Name         string
    Description  string
    Endpoint     string
    Capabilities map[string]interface{}

    // SAGE-specific (optional)
    DID       *string
    PublicKey interface{}
    Owner     *string
    IsActive  bool

    CreatedAt time.Time
    UpdatedAt time.Time
}
```

---

## Type Definitions

### 1. Message Types

#### MessageRole
```go
type MessageRole string

const (
    MessageRoleUser  MessageRole = "user"
    MessageRoleAgent MessageRole = "agent"
)
```

#### Part Interface
```go
type Part interface {
    GetKind() string
    Validate() error
}

type PartKind string

const (
    PartKindText PartKind = "text"
    PartKindFile PartKind = "file"
    PartKindData PartKind = "data"
)
```

#### TextPart
```go
type TextPart struct {
    Kind     string
    Text     string
    Metadata map[string]interface{}
}

func (t *TextPart) GetKind() string { return string(PartKindText) }
func (t *TextPart) Validate() error { /* validation logic */ }
```

#### FilePart
```go
type FilePart struct {
    Kind     string
    File     FileContent
    Metadata map[string]interface{}
}

type FileContent interface {
    GetName() string
    GetMimeType() string
}

type FileWithBytes struct {
    Name     string
    MimeType string
    Bytes    []byte  // decoded from base64
}

type FileWithURI struct {
    Name     string
    MimeType string
    URI      string
}

func (f *FilePart) GetKind() string { return string(PartKindFile) }
func (f *FilePart) Validate() error { /* validation logic */ }
```

#### DataPart
```go
type DataPart struct {
    Kind     string
    Data     interface{}
    Metadata map[string]interface{}
}

func (d *DataPart) GetKind() string { return string(PartKindData) }
func (d *DataPart) Validate() error { /* validation logic */ }
```

### 2. Task Types

#### TaskState
```go
type TaskState string

const (
    TaskStateSubmitted     TaskState = "submitted"
    TaskStateWorking       TaskState = "working"
    TaskStateInputRequired TaskState = "input-required"
    TaskStateCompleted     TaskState = "completed"
    TaskStateCanceled      TaskState = "canceled"
    TaskStateFailed        TaskState = "failed"
    TaskStateRejected      TaskState = "rejected"
    TaskStateAuthRequired  TaskState = "auth-required"
    TaskStateUnknown       TaskState = "unknown"
)

func (s TaskState) IsTerminal() bool {
    return s == TaskStateCompleted ||
           s == TaskStateCanceled ||
           s == TaskStateFailed ||
           s == TaskStateRejected
}
```

#### Task
```go
type Task struct {
    ID        string
    ContextID string
    Kind      string
    Status    TaskStatus
    Artifacts []Artifact
    History   []Message
    Metadata  map[string]interface{}

    CreatedAt time.Time
    UpdatedAt time.Time
}

type TaskStatus struct {
    State     TaskState
    Message   *Message
    Timestamp time.Time
}
```

#### Artifact
```go
type Artifact struct {
    ArtifactID  string
    Name        string
    Description string
    Parts       []Part
    Metadata    map[string]interface{}
    Extensions  []string

    CreatedAt time.Time
}
```

### 3. Agent Types

```go
type Agent struct {
    ID           string
    Name         string
    Description  string
    Endpoint     string
    Capabilities map[string]interface{}

    // SAGE-specific (optional)
    DID       *string
    PublicKey interface{}
    Owner     *string
    IsActive  bool

    Metadata  map[string]interface{}
    CreatedAt time.Time
    UpdatedAt time.Time
}

type AgentCapability struct {
    Name        string
    Version     string
    Description string
    Parameters  map[string]interface{}
}
```

### 4. Security Types

```go
type SecurityMetadata struct {
    Mode      ProtocolMode
    AgentDID  string
    Nonce     string
    Timestamp time.Time
    Sequence  uint64
    Signature *SignatureData
}

type SignatureData struct {
    Algorithm    SignatureAlgorithm
    KeyID        string
    Signature    []byte
    SignedFields []string
}

type SignatureAlgorithm string

const (
    AlgorithmEdDSA         SignatureAlgorithm = "EdDSA"
    AlgorithmES256K        SignatureAlgorithm = "ES256K"
    AlgorithmECDSA         SignatureAlgorithm = "ECDSA"
    AlgorithmECDSASecp256k1 SignatureAlgorithm = "ECDSA-secp256k1"
)

type ProtocolMode string

const (
    ProtocolModeA2A   ProtocolMode = "a2a"
    ProtocolModeSAGE  ProtocolMode = "sage"
    ProtocolModeAuto  ProtocolMode = "auto"
)
```

### 5. Context Types

```go
type Context struct {
    ID       string
    AgentID  string
    Metadata map[string]interface{}

    CreatedAt time.Time
    UpdatedAt time.Time
    ExpiresAt *time.Time
}
```

---

## Conversion Strategy

### A2A to ADK Conversion
```go
// Convert A2A Message to ADK Message
func FromA2AMessage(a2aMsg *a2a.Message) (*Message, error)

// Convert A2A Task to ADK Task
func FromA2ATask(a2aTask *a2a.Task) (*Task, error)

// Convert A2A Part to ADK Part
func FromA2APart(a2aPart a2a.Part) (Part, error)
```

### ADK to A2A Conversion
```go
// Convert ADK Message to A2A Message
func (m *Message) ToA2AMessage() (*a2a.Message, error)

// Convert ADK Task to A2A Task
func (t *Task) ToA2ATask() (*a2a.Task, error)

// Convert ADK Part to A2A Part
func PartToA2A(part Part) (a2a.Part, error)
```

---

## Validation Rules

### Message Validation
- MessageID must be non-empty
- Role must be valid (user/agent)
- Parts must not be empty
- If Security is present, AgentDID and Nonce must be non-empty
- Timestamp must be within reasonable range

### Task Validation
- ID and ContextID must be non-empty
- State must be valid TaskState
- Status.Timestamp must be set
- Artifacts must have unique ArtifactIDs

### Part Validation
- Kind must match actual type
- TextPart: Text must be non-empty
- FilePart: File content must be valid (bytes or URI)
- DataPart: Data must be non-nil

---

## File Organization

```
pkg/types/
├── doc.go              # Package documentation
├── message.go          # Message, Part types
├── message_test.go     # Message tests
├── task.go             # Task, TaskStatus, Artifact
├── task_test.go        # Task tests
├── agent.go            # Agent, AgentCapability
├── agent_test.go       # Agent tests
├── security.go         # SecurityMetadata, SignatureData
├── security_test.go    # Security tests
├── context.go          # Context types
├── context_test.go     # Context tests
├── conversion.go       # A2A <-> ADK conversion
├── conversion_test.go  # Conversion tests
├── validation.go       # Validation logic
├── validation_test.go  # Validation tests
└── helpers.go          # Helper functions (ID generation, etc.)
```

---

## Testing Strategy

### Unit Tests (Table-Driven)
```go
func TestMessage_Validate(t *testing.T) {
    tests := []struct {
        name    string
        msg     *Message
        wantErr bool
        errMsg  string
    }{
        {
            name: "valid A2A message",
            msg: &Message{
                MessageID: "msg-123",
                Role: MessageRoleUser,
                Parts: []Part{&TextPart{Text: "Hello"}},
                Kind: "message",
            },
            wantErr: false,
        },
        {
            name: "valid SAGE message",
            msg: &Message{
                MessageID: "msg-456",
                Role: MessageRoleAgent,
                Parts: []Part{&TextPart{Text: "Response"}},
                Kind: "message",
                Security: &SecurityMetadata{
                    Mode: ProtocolModeSAGE,
                    AgentDID: "did:sage:eth:0x123",
                    Nonce: "nonce-789",
                    Timestamp: time.Now(),
                },
            },
            wantErr: false,
        },
        {
            name: "invalid - empty MessageID",
            msg: &Message{
                MessageID: "",
                Role: MessageRoleUser,
                Parts: []Part{&TextPart{Text: "Hello"}},
            },
            wantErr: true,
            errMsg: "MessageID is required",
        },
        {
            name: "invalid - SAGE without AgentDID",
            msg: &Message{
                MessageID: "msg-789",
                Role: MessageRoleUser,
                Parts: []Part{&TextPart{Text: "Hello"}},
                Security: &SecurityMetadata{
                    Mode: ProtocolModeSAGE,
                    // Missing AgentDID
                },
            },
            wantErr: true,
            errMsg: "AgentDID required for SAGE mode",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.msg.Validate()
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
            if tt.wantErr && err != nil && tt.errMsg != "" {
                if !strings.Contains(err.Error(), tt.errMsg) {
                    t.Errorf("error message = %v, want %v", err.Error(), tt.errMsg)
                }
            }
        })
    }
}
```

### Conversion Tests
- Test A2A → ADK → A2A roundtrip
- Test ADK → A2A → ADK roundtrip
- Test security metadata preservation
- Test metadata preservation
- Test error cases (invalid data, missing fields)

### JSON Marshaling Tests
- Test JSON marshaling/unmarshaling
- Test polymorphic Part handling
- Test optional field handling
- Test compatibility with A2A JSON format

---

## Success Criteria

- [ ] All type definitions implemented
- [ ] Validation logic for all types
- [ ] Conversion functions (A2A ↔ ADK)
- [ ] 90%+ test coverage
- [ ] All tests passing
- [ ] Godoc comments on all exported types
- [ ] Example usage in tests
- [ ] No breaking changes to A2A compatibility

---

## Dependencies

- `github.com/sage-x-project/sage-a2a-go/protocol` - A2A types
- `github.com/google/uuid` - ID generation
- Standard library: `time`, `encoding/json`, `fmt`, `errors`

---

## Implementation Order

1. **Phase 1**: Basic types without validation
   - Message, Part types (TextPart, FilePart, DataPart)
   - Task, TaskStatus, Artifact
   - Agent, AgentCapability
   - Security types
   - Context

2. **Phase 2**: Validation logic
   - Implement Validate() methods
   - Add validation tests

3. **Phase 3**: Conversion logic
   - A2A → ADK conversion
   - ADK → A2A conversion
   - Conversion tests

4. **Phase 4**: Helpers and utilities
   - ID generation
   - Constructor functions
   - Helper tests

---

## Next Steps

1. Create feature branch: `feature/core-types`
2. Implement types (TDD approach)
3. Write tests first for each type
4. Implement to pass tests
5. Achieve 90%+ coverage
6. Review and refactor
7. Create PR to `dev`

---

**Document Owner**: SAGE ADK Team
**Last Updated**: 2025-10-07 00:15:10
**Next Review**: After implementation
