// Copyright (C) 2025 sage-x-project
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

// SPDX-License-Identifier: LGPL-3.0-or-later

package types

import (
	"encoding/json"
	"fmt"
	"time"
)

// TaskState represents the lifecycle state of a task.
type TaskState string

const (
	// TaskStateSubmitted is the state when the task is received but not yet processed.
	TaskStateSubmitted TaskState = "submitted"
	// TaskStateWorking is the state when the task is actively being processed.
	TaskStateWorking TaskState = "working"
	// TaskStateInputRequired is the state when the task requires additional input.
	TaskStateInputRequired TaskState = "input-required"
	// TaskStateCompleted is the state when the task finished successfully.
	TaskStateCompleted TaskState = "completed"
	// TaskStateCanceled is the state when the task was canceled before completion.
	TaskStateCanceled TaskState = "canceled"
	// TaskStateFailed is the state when the task failed during processing.
	TaskStateFailed TaskState = "failed"
	// TaskStateRejected is the state when the task was rejected by the agent.
	TaskStateRejected TaskState = "rejected"
	// TaskStateAuthRequired is the state when the task requires authentication.
	TaskStateAuthRequired TaskState = "auth-required"
	// TaskStateUnknown is the state when the task is in an unknown state.
	TaskStateUnknown TaskState = "unknown"
)

// IsTerminal returns true if the task state is a terminal state.
func (s TaskState) IsTerminal() bool {
	return s == TaskStateCompleted ||
		s == TaskStateCanceled ||
		s == TaskStateFailed ||
		s == TaskStateRejected
}

// IsValid checks if the task state is valid.
func (s TaskState) IsValid() bool {
	return s == TaskStateSubmitted ||
		s == TaskStateWorking ||
		s == TaskStateInputRequired ||
		s == TaskStateCompleted ||
		s == TaskStateCanceled ||
		s == TaskStateFailed ||
		s == TaskStateRejected ||
		s == TaskStateAuthRequired ||
		s == TaskStateUnknown
}

// TaskStatus represents the current status of a task.
type TaskStatus struct {
	// State is the current lifecycle state.
	State TaskState `json:"state"`
	// Message is the optional message associated with the status.
	Message *Message `json:"message,omitempty"`
	// Timestamp is the time of the status change.
	Timestamp time.Time `json:"timestamp"`
}

// Validate validates the task status.
func (s *TaskStatus) Validate() error {
	if !s.State.IsValid() {
		return fmt.Errorf("invalid task state: %s", s.State)
	}
	if s.Timestamp.IsZero() {
		return fmt.Errorf("status timestamp is required")
	}
	if s.Message != nil {
		if err := s.Message.Validate(); err != nil {
			return fmt.Errorf("status message validation failed: %w", err)
		}
	}
	return nil
}

// Artifact represents an output generated by a task.
type Artifact struct {
	// ArtifactID is the unique identifier for the artifact.
	ArtifactID string `json:"artifactId"`
	// Name is the name of the artifact.
	Name string `json:"name,omitempty"`
	// Description is the description of the artifact.
	Description string `json:"description,omitempty"`
	// Parts is the content parts of the artifact.
	Parts []Part `json:"parts"`
	// Metadata is optional metadata for the artifact.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Extensions is the optional list of extension URIs.
	Extensions []string `json:"extensions,omitempty"`

	// Timestamps
	CreatedAt time.Time `json:"createdAt"`
}

// Validate validates the artifact.
func (a *Artifact) Validate() error {
	if a.ArtifactID == "" {
		return fmt.Errorf("ArtifactID is required")
	}
	if len(a.Parts) == 0 {
		return fmt.Errorf("at least one part is required")
	}

	// Validate each part
	for i, part := range a.Parts {
		if err := part.Validate(); err != nil {
			return fmt.Errorf("part %d validation failed: %w", i, err)
		}
	}

	return nil
}

// UnmarshalJSON implements custom JSON unmarshaling for Artifact.
func (a *Artifact) UnmarshalJSON(data []byte) error {
	type Alias Artifact
	temp := &struct {
		Parts []json.RawMessage `json:"parts"`
		*Alias
	}{
		Alias: (*Alias)(a),
	}

	if err := json.Unmarshal(data, &temp); err != nil {
		return fmt.Errorf("failed to unmarshal artifact: %w", err)
	}

	// Unmarshal parts
	a.Parts = make([]Part, 0, len(temp.Parts))
	for i, rawPart := range temp.Parts {
		part, err := unmarshalPart(rawPart)
		if err != nil {
			return fmt.Errorf("failed to unmarshal artifact part %d: %w", i, err)
		}
		a.Parts = append(a.Parts, part)
	}

	return nil
}

// Task represents a unit of work being processed by the agent.
type Task struct {
	// ID is the unique task identifier.
	ID string `json:"id"`
	// ContextID is the unique context identifier for the task.
	ContextID string `json:"contextId"`
	// Kind is the event type discriminator (always "task").
	Kind string `json:"kind"`
	// Status is the current task status.
	Status TaskStatus `json:"status"`
	// Artifacts is the accumulated artifacts generated by the task.
	Artifacts []Artifact `json:"artifacts,omitempty"`
	// History is the history of messages exchanged for this task.
	History []Message `json:"history,omitempty"`
	// Metadata is the optional metadata associated with the task.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// Timestamps
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// Validate validates the task.
func (t *Task) Validate() error {
	if t.ID == "" {
		return fmt.Errorf("task ID is required")
	}
	if t.ContextID == "" {
		return fmt.Errorf("ContextID is required")
	}

	// Validate status
	if err := t.Status.Validate(); err != nil {
		return fmt.Errorf("status validation failed: %w", err)
	}

	// Validate artifacts
	for i, artifact := range t.Artifacts {
		if err := artifact.Validate(); err != nil {
			return fmt.Errorf("artifact %d validation failed: %w", i, err)
		}
	}

	// Validate history messages
	for i, msg := range t.History {
		if err := msg.Validate(); err != nil {
			return fmt.Errorf("history message %d validation failed: %w", i, err)
		}
	}

	return nil
}

// UpdateState updates the task state and timestamp.
func (t *Task) UpdateState(state TaskState, message *Message) {
	t.Status.State = state
	t.Status.Timestamp = time.Now()
	t.Status.Message = message
	t.UpdatedAt = time.Now()
}

// AddArtifact adds an artifact to the task.
func (t *Task) AddArtifact(artifact Artifact) {
	t.Artifacts = append(t.Artifacts, artifact)
	t.UpdatedAt = time.Now()
}

// AddHistoryMessage adds a message to the task history.
func (t *Task) AddHistoryMessage(message Message) {
	t.History = append(t.History, message)
	t.UpdatedAt = time.Now()
}

// NewTask creates a new Task with initial state (Submitted).
func NewTask(id string, contextID string) *Task {
	now := time.Now()
	return &Task{
		ID:        id,
		ContextID: contextID,
		Kind:      "task",
		Status: TaskStatus{
			State:     TaskStateSubmitted,
			Timestamp: now,
		},
		Metadata:  make(map[string]interface{}),
		Artifacts: []Artifact{},
		History:   []Message{},
		CreatedAt: now,
		UpdatedAt: now,
	}
}

// TaskStatusUpdateEvent indicates a change in the task's lifecycle state.
type TaskStatusUpdateEvent struct {
	// ContextID is the context ID of the task.
	ContextID string `json:"contextId"`
	// TaskID is the ID of the task.
	TaskID string `json:"taskId"`
	// Kind is the event type discriminator.
	Kind string `json:"kind"`
	// Status is the new status.
	Status TaskStatus `json:"status"`
	// Final is a flag indicating if this is the final event for the task.
	Final bool `json:"final"`
	// Metadata is optional metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// IsFinal returns true if this is a final event.
func (e *TaskStatusUpdateEvent) IsFinal() bool {
	return e.Final
}

// TaskArtifactUpdateEvent indicates a new or updated artifact chunk.
type TaskArtifactUpdateEvent struct {
	// ContextID is the context ID of the task.
	ContextID string `json:"contextId"`
	// TaskID is the ID of the task.
	TaskID string `json:"taskId"`
	// Kind is the event type discriminator.
	Kind string `json:"kind"`
	// Artifact is the artifact data.
	Artifact Artifact `json:"artifact"`
	// Append is a hint for the client to append data (streaming).
	Append *bool `json:"append,omitempty"`
	// LastChunk is a flag indicating if this is the final chunk of an artifact stream.
	LastChunk *bool `json:"lastChunk,omitempty"`
	// Metadata is optional metadata.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// IsFinal returns true if this is the final artifact event.
func (e *TaskArtifactUpdateEvent) IsFinal() bool {
	return e.LastChunk != nil && *e.LastChunk
}
